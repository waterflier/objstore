#基本OK
1）引入并发，在并发下操作的原子性保证与正确性保证
如何模拟模拟并发 (读并发，写并发，读写并发)

通过测试发现并发问题
    Update OK
    Read OK
    Remove OK


修正bug:分析方法
    并发的问题并不能完全靠测试->验证的方法来解决（通过测试的不一定没bug)
    掌握正确的分析方法->寻找代码的状态依赖逻辑
                   ->一个函数如果是无状态的，那么其本身基本上就是可并发的。但在发起调用的地方，要发现构造的参数是否是允许并发的
目前做到了基本接口的强并发保证

高级接口
UpdateRange
ReadRange

首先关于其原子性定义
写原子
UpdateObjByRange(obj1,[0,200],"aaaa...");//stepA
UpdateObjByRange(obj2,[300,400],"bbbb...");//stepB
这两个操作如果并行执行，那么结果应该是文件的[0,200]变成"aaa...",[300,400]变成"bbbb..." (结果和两个原子操作实际执行的顺序无关)，这与UpdateObj的定义是不同的 （可并行则尽量并行，部分更新的定义里没有对其它部分的保证）

读原子
ReadObjByRange(obj1,[100,350]);//stepC
当stepC与stepA,stepB并行时，有4种正确的结果:读取到原内容、读取到stepA完成后的内容、读取到stepB完成后的内容、读取到stepA,stepB都完成后的内容


2）访问隔离：隔离接口与实现

首先，代码重构：工具代码，核心逻辑，测试代码

实现思路A：基于服务化的方法
简化：多线程+消息队列

实现思路B 基于操作的强原子性的方法

原子性要求与正确性要求说带来的实现几乎一样，这是一种巧合么？


在并发情况下对串行操作的结果进行保证

obj = read(id)
obj.count = obj.count + 1
write(obj)

引入锁的概念（悲观锁，乐观锁）
在思路A上实现锁

悲观锁实现


添加日志操作

（在思路B上实现锁）


结论：使用实现思路A，

服务化带来的其他好处：可以使用内存和一些其它的CPU支持的原子操作
